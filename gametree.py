''' Source: CS 151 Project 2 Starter Code '''

import random
import argparse
import time
from mcts import *


class BinaryGameTree:
    '''A fairly general game tree representation. Limitations: every move has
    exactly 2 options and every node in a given level must be associated with
    the same player.'''

    def __init__(self, turnList, payoffs):
        '''Ininitializes the tree.
           turnList: a list representing the order in which turns are taken
           (-1 for min, 0 for chance, 1 for max) payoffs: a list of the
           payoffs of the leaves, from left to right'''
        for t in turnList:
            if t not in [-1, 0, 1]:
                raise ValueError("Unrecognized turn label: " + str(t))

        if len(payoffs) != 2**(len(turnList)):
            raise ValueError("Wrong number of payoffs: " +
                             str(len(payoffs)) + " (expected " +
                             str(2**(len(turnList))))

        self.__turnList = turnList
        self.__payoffs = payoffs
        self.__turn = 0
        self.__curState = ""

    def getState(self):
        '''Returns the state of the tree (either "Root" or a string
        of 0s and 1s representing the actions taken to reach this node.'''
        if self.__curState == "":
            return "Root"
        else:
            return self.__curState

    def setState(self, state):
        '''Takes a state as generated by getState and sets the state of the
        game accordingly.'''
        if state == "Root":
            self.__curState = ""
        else:
            if len(state) == 0 or len(state) > len(self.__turnList):
                raise ValueError(
                    "Invalid state string: length " + str(len(state)))
            for c in state:
                if c not in ["0", "1"]:
                    raise ValueError("Unexpected state symbol: " + c)
            self.__curState = state
        self.__turn = len(self.__curState)

    def getSuccessors(self, state):
        '''Returns the two successor states in the form of tuples:
        (next state, action taken to get there,
        whose turn it is in that state, final score).
        For the last two items, see getTurn() and finalScore().'''
        currentState = self.getState()
        succ = []
        self.setState(state)
        for a in self.legalMoves():
            self.move(a)
            succ.append(
                (self.getState(), a, self.getTurn(), self.finalScore()))
            self.setState(state)
        self.setState(currentState)
        return succ

    def legalMoves(self):
        '''Returns a list of legal moves in the current state (always 0, 1
        unless the game is terminal).'''
        if self.__turn < len(self.__turnList):
            return [0, 1]
        else:
            return []

    def move(self, action):
        '''Takes an action (0 or 1) and changes the state accordingly.'''
        if action not in [0, 1]:
            raise ValueError("Unrecognized action: " + str(action))

        if self.__turn >= len(self.__turnList):
            raise ValueError("Illegal move: game is terminated.")
        else:
            self.__curState += str(action)
            self.__turn += 1

    def finalScore(self):
        '''If the game is not over, returns None. Otherwise, returns the
        payoff at the current leaf node.'''
        if self.__turn < len(self.__turnList):
            return None
        else:
            return self.__payoffs[int(self.__curState, 2)]

    def isTerminal(self):
        '''Returns true if the game is over and false otherwise.'''
        return self.__turn >= len(self.__turnList)

    def getTurn(self):
        '''Returns a number indicating whose turn it is in the current state:
        -1 for min, 0 for chance, 1 for max, and 2 if the state is terminal.'''
        if self.__turn >= len(self.__turnList):
            return 2
        else:
            return self.__turnList[self.__turn]

    def __str__(self):
        '''Returns a string representing the game tree.'''
        treeStr = ""
        bottomRow = ""
        nodePositions = []
        for i in range(len(self.__payoffs)):
            x = self.__payoffs[i]
            nodePositions.append(len(bottomRow) + (len(str(x))//2))
            bottomRow += str(x) + " "
            if i % 2 == 1:
                bottomRow += " "
        treeStr += bottomRow
        for row in range(len(self.__turnList)-1, -1, -1):
            edgeRow = [" "]*len(bottomRow)
            for p in nodePositions:
                edgeRow[p] = "|"
            treeStr = "".join(edgeRow) + "\n" + treeStr

            nodeRow = [" "]*len(bottomRow)
            newNodePositions = []
            for i in range(0, len(nodePositions), 2):
                for j in range(nodePositions[i], nodePositions[i+1]+1):
                    nodeRow[j] = "-"
                newPos = (nodePositions[i]+nodePositions[i+1])//2
                if self.__turnList[row] == -1:
                    nodeRow[newPos] = "V"
                elif self.__turnList[row] == 1:
                    nodeRow[newPos] = "^"
                elif self.__turnList[row] == 0:
                    nodeRow[newPos] = "O"
                newNodePositions.append(newPos)
            treeStr = "".join(nodeRow) + "\n" + treeStr

            nodePositions = newNodePositions
        return treeStr

    def strategyStr(self, strategy=None):
        treeStr = ""
        bottomRow = ""
        nodePositions = []
        for i in range(len(self.__payoffs)):
            x = self.__payoffs[i]
            nodePositions.append(len(bottomRow) + (len(str(x))//2))
            bottomRow += str(x) + " "
            if i % 2 == 1:
                bottomRow += " "
            else:
                bottomRow += " " * \
                    (max(len(str(x)), len(str(self.__payoffs[i+1])))+4)
        treeStr += bottomRow
        for row in range(len(self.__turnList)-1, -1, -1):
            edgeRow = [" "]*len(bottomRow)
            for p in range(len(nodePositions)):
                state = format(p//2, '0'+str(row)+'b')
                curState = self.getState()
                self.setState(state)
                strategy[state] = mcts(self)
                self.setState(curState)
                if row == 0:
                    state = "Root"
                if strategy == None or \
                        (state in strategy and self.__turnList[row] != 0 and
                         strategy[state][0] != p % 2):
                    edgeRow[nodePositions[p]] = "|"
                elif strategy != None and state in strategy and \
                        (strategy[state][0] == p % 2 or
                            self.__turnList[row] == 0):
                    edgeRow[nodePositions[p]] = "#"

            nodeRow = [" "]*len(bottomRow)
            labelRow = [" "]*len(bottomRow)
            newNodePositions = []
            for i in range(0, len(nodePositions), 2):
                newPos = (nodePositions[i]+nodePositions[i+1])//2
                state = format(i//2, '0'+str(row)+'b')
                if row == 0:
                    state = "Root"

                for j in range(nodePositions[i], newPos):
                    if strategy == None or \
                            (state in strategy and
                             self.__turnList[row] != 0 and
                             strategy[state][0] == 1):
                        nodeRow[j] = "_"
                    elif strategy != None and state in strategy and \
                            (strategy[state][0] == 0 or
                             self.__turnList[row] == 0):
                        nodeRow[j] = "#"
                for j in range(newPos, nodePositions[i+1]+1):
                    if strategy == None or \
                        (state in strategy and self.__turnList[row] != 0 and
                         strategy[state][0] == 0):
                        nodeRow[j] = "_"
                    elif strategy != None and state in strategy and \
                            (strategy[state][0] == 1 or
                             self.__turnList[row] == 0):
                        nodeRow[j] = "#"
                nodeRow[newPos] = " "
                nodeRow[newPos-1] = "/"
                nodeRow[newPos+1] = "\\"

                nodeRow[nodePositions[i]] = "."
                nodeRow[nodePositions[i+1]] = "."
                if strategy != None and state in strategy:
                    if self.__turnList[row] == 0:
                        nodeRow[nodePositions[i]] = "#"
                        nodeRow[nodePositions[i+1]] = "#"
                    else:
                        nodeRow[nodePositions[i+strategy[state][0]]] = "#"

                score = ""
                if strategy != None and state in strategy:
                    score = str(strategy[state][1])
                startPos = newPos - len(score)//2
                for j in range(len(score)):
                    edgeRow[startPos+j] = score[j]

                if self.__turnList[row] == -1:
                    labelRow[newPos] = "V"
                elif self.__turnList[row] == 1:
                    labelRow[newPos] = "^"
                elif self.__turnList[row] == 0:
                    labelRow[newPos] = "O"
                newNodePositions.append(newPos)

            treeStr = "".join(labelRow) + "\n" + "".join(nodeRow) + \
                "\n" + "".join(edgeRow) + "\n" + treeStr

            nodePositions = newNodePositions
        return treeStr


def main():
    parser = argparse.ArgumentParser(
        description='Solve simple 2-player game trees, and print the results.')
    parser.add_argument('-d', '--depth', type=int, default=4,
                        help='DEPTH gives the number of turn layers in the ' +
                        'tree')
    parser.add_argument('-p', '--prune', action='store_true', default=False,
                        help='Use alpha-beta pruning in minimax (has no ' +
                        'effect with -c)')
    parser.add_argument('-t', '--turns', type=int, nargs='+', default=[],
                        help='Use the given turn order (rather than ' +
                        'randomly generating it). Give a list of turns: -1 ' +
                        'is min, 1 is max, and 0 is chance. Overrides ' +
                        '--depth if there is a mismatch.')
    parser.add_argument('-y', '--payoffs', type=int, nargs='+', default=[],
                        help='Use the given payoffs in terminal nodes ' +
                        '(rather than randomly generating them). Give a ' +
                        'list of integer payoffs for the bottom layer from ' +
                        'left to right. Will ignore any extra payoffs and ' +
                        'will fill in missing payoffs randomly between -5 ' +
                        'and 5 if too few are given.')
    parser.add_argument('-c', '--chance', action='store_true', default=False,
                        help='Use expectiminimax to solve the game tree ' +
                        'and, if randomly generating the turn order, ' +
                        'include chance nodes in the tree')

    args = parser.parse_args()

    if len(args.turns) > 0:
        turns = args.turns
    else:
        possibleTurns = [-1, 1]
        if args.chance:
            possibleTurns.append(0)
        turns = possibleTurns[:]
        for i in range(args.depth - len(possibleTurns)):
            turns.append(random.choice(possibleTurns))
        random.shuffle(turns)
        turns = turns[:args.depth]

    payoffs = []
    for i in range(2**(len(turns))):
        if i < len(args.payoffs):
            payoffs.append(args.payoffs[i])
        else:
            payoffs.append(random.randint(-5, 5))

    problem = BinaryGameTree(turns, payoffs)

    strategy = {}
    strategy[problem.getState()] = mcts(problem)

    print(problem.strategyStr(strategy))


if __name__ == "__main__":
    main()
